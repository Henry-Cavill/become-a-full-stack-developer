# 二、面向对象

## 目录

- [面向对象](#面向对象)  
  - [面向对象基本概念](#面向对象基本概念)
  - [内存里的对象](#内存里的对象)
  - [面向对象的特殊语法](#面向对象的特殊语法)
  - [修改权限修饰符](#修改权限修饰符)
  - [面向对象三大特征之封装](#面向对象三大特征之封装)
  - [面向对象三大特征之继承](#面向对象三大特征之继承)
  - [面向对象三大特征之多态](#面向对象三大特征之多态)



## 面向对象

### 面向对象基本概念

面向过程的思想：简单理解就是程序是「动词」的集合，即程序功能是由一系列有序的动作来完成。
    
面向对象的思想：简单理解就是程序是由一系列的对象（消息）+ 消息组成，即程序是由一系列的对象和对象间的消息组成。  
  - 运行中的程序，由多个个体（也就是对象）组成。
  - 运行中的个体，需要相互协作，共同完成程序的功能。

要想写出面向对象的程序，首先要学会构建**面向对象程序的基本组成单位 —— 对象**。  

类：同种物体在属性和行为上的集合与抽象，是构造对象的模板。

类和对象的关系：
- 类描述出了，该种类型对象共有的属性和行为。

- 类描述了，对象有哪些属性，具备哪些行为（包括行为的具体实现）。

- 但是各个对象的属性取什么值，只有具体的对象能确定。

Java 语言中定义类，其实就是定义类的成员（成员变量和成员方法）：  
- 成员变量：就是事物的属性。  
  成员变量和局部变量定义的位置不同，成员变量定义在方法体之外。

- 成员方法：就是事物的行为。  
  之前学的方法的修饰符都是 public static，修饰符中去掉 static 修饰符的方法就是成员方法。

例：  
定义一个学生类：  
- 属性（成员变量）：姓名，性别，年龄，学号
- 行为（成员方法）：吃饭，睡觉，学习  

有了类定义，我们就有了对同种类型的对象的描述，我们就可以创建学生对象了
- 创建对象：`类名  对象名 = new 类名();`

- 给对象的属性赋值, 或者访问对象的属性：`对象名.成员变量;`

- 访问对象的行为：`对象名.成员方法;`

成员变量：定义在类体中，方法体之外的变量。

局部变量和成员变量的比较：
- 在类中定义的位置不同。

- 在内存中的位置不同。  
  1. 局部变量，都是存储在方法对应的栈帧中的；
  2. 成员变量，存储在堆上，在对象的内存中。

- 初始化值不同。  
  1. 局部变量，局部变量没有天生的初始值，必须在使用之前，用代码初始化成员变量的值。
  2. 成员变量，成员变量存储在堆上的，堆上的成员变量，天然有默认初值。

- 生命周期不同。
  1. 因为局部变量是存储在栈帧中的，因此，随着栈帧的存在而存在，随着栈帧的销毁而销毁。
  2. 成员变量是在堆上的。在对象的内存空间中，成员变量随着对象的存在而存在，随着对象的销毁而销毁。

### 内存里的对象

类本身属于引用数据类型，对于引用数据类型的执行分析，必须结合内存操作来看。
- 堆内存保存每一个对象的属性内容，堆内存需要用关键字 new 才可以开辟，如果一个对象没有对应的堆内存指向，将无法使用；  

- 栈内存保存的是一块堆内存的地址数值，可以把它想象成一个 int 类型变量（每一个 int 类型变量只能存放一个数组），所以每一块栈内存只能够保留一块堆内存地址。

对象的内存图解：  
![图解](./img/p16.png)


### 面向对象的特殊语法

**（1）构造方法**  

构造方法的作用就是使得 JVM 在构造对象的时候，进行成员变量的初始化。  
其定义的原则是：  
- 方法名称与类名相同；
- 没有返回值类型声明；
- 数构造方法可以进行重载。  

当我们没有在类中定义任何一个构造方法的时候，JVM 会自动添加一个默认的构造方法（无参构造方法）。但是，一旦我们自己在类定义中，定义了哪怕只有一个构造方法，JVM 就不会再自动帮我们添加那个无参构造方法了。
- 这和 JVM 执行固定流程有关系：  
  开辟对象的存储空间 -> 给对象成员变量赋予默认初值 -> 使用构造方法，初始化对象成员变量的值

构造方法何时执行：
由 JVM 在创建对象的最后一步，执行构造方法，给对象的成员变量赋予 Coder 传递的初值。


**（2）this关键字**  

成员变量的隐藏问题：当方法中定义了和类中同名的成员变量时，在方法体中，通过同名的变量名来访问变量值，只能访问到方法中的那个局部同名变量的值，而访问不到，同名成员变量的值。  
在方法体中，就好像同名成员变量，被同名局部变量给隐藏起来了。

this 关键字：代表对象自身的引用。  
- 在构造方法中的 this，指代的当前对象，其实就是，构造方法执行时，JVM 正在创建的那个对象。

- 对于普通成员方法而言，this 指代的对象 `对象名.方法()` 指的是对象名对应的对象。  

this 关键字的作用：
- 解决成员变量的隐藏的问题。

- 访问对象的成员（访问当前对象的成员变量值，访问当前对象的成员方法）。

- 访问对象的构造方法。
  1. 只能在某个构造方法体中使用 this 调用构造方法；
  2. 必须处在该构造方法体的第一条语句的位置。

**（3）static关键字**  

static 关键字：可以修饰成员变量和成员方法。  
按照严格意义上的面向对象思想，static 修饰的成员变量和成员方法都不能算做类中定义的成员。我们之所以称 static 修饰的变量为静态成员变量、方法为静态成员方法，这是习惯上的称呼。

static 关键字的特点：  
- 被类的所有成员所共享（这点判定是否使用 static）。   
  1. 当 static 修饰了成员变量，该成员变量的值就不存在其存储对象中，而是单独存储一份，被类的所有对象所共享；  
  2. 当 static 修饰成员方法时，该方法被当前类的所有方法共享。

- 可以通过类名访问。  
  1. 可以通过类名直接访问 static 成员变量的值；  
  2. 通过类名直接调用 static 成员方法。

- 随着类的加载而加载。  
  1. static 成员变量，随着类加载过程，其实就已经在方法区中，分配了内存；
  2. static 成员方法, 一旦类加载完毕，就可以直接访问，而不必等待创建对象，然后再用 `对象名.访问方法` 的方式。

- 优先于对象而存在。  
  - 不依赖于对象而存在。  
     1. 成员变量的角度来理解：  
     static修饰的成员变量，不依赖于对象而存在，因为static修饰的成员变量的值，不再存储在该类的每个对象中。  
     作为对比，没有被static修饰的成员变量，都依赖于对象而存在，因为他们的值，都存储在对象中

     2. 成员方法角度：  
     被 static 修饰的成员方法，在没有对象存在的情况下，也可以直接通过类名来调用方法。  
     作为对比，没有被 static 修饰的普通成员方法，它依赖于对象而存在。原因是普通成员方法中，可以访问普通成员变量的值，而普通对象的值又是依赖于对象而存在的。

  - 先出现在内存。  
    静态成员变量， 一定先于没有被 static 修饰的普通成员变量，出现在内存中。


static 关键字注意事项：  
- 非静态成员变量（非静态的成员方法）不能在静态上下文（静态方法的方法体）中被访问。  
   1. 因为静态方法，优先于对象而存在。  
      我们可以在没有任何对象存在的情况下，可以直接通过类名执行静态方法，所以静态方法是访问不到当前对象的普通成员变量值（因为此时，当前对象不存在）。

    2. 之所以静态方法方法体中，不能访问非静态的成员方法，是因为，如果静态方法可以直接调用非静态的的方法，而非静态的方法可以去访问当前对象的成员变量值，而当前对象，此时可能还不存在。

- 静态方法的方法体中是没有 static 关键字的。

- 静态方法的使用场景：  
  静态方法和非静态方法除了访问方式不同，最大的区别就是静态方法可以访问到的数据集合（静态方法方法体中，不能直接访问非静态的成员变量）。所以通常静态方法所访问的数据要么是静态的成员变量，要么是方法的形式参数。  
  通常定义静态方法都是为了方便使用该方法的功能（工具方法），使其不用创建对象就可以使用。


**（4）代码块**  

在 Java 中，使用 `{}` 括起来的代码被称为代码块，根据其位置和声明的不同，可以分为局部代码块、构造代码块、静态代码块、同步代码块(多线程讲解)。  

局部代码块（开发中不会用）：方法体中的用 `{}` 括起来的一段代码。  
- 执行时机：随着方法的执行而执行。  

- 优点：限定变量生命周期，及早释放，提高内存利用率。  
  （这个优点理论上确实存在，但是这个优点，在现在 JVM 中的效果微乎其微，甚至可以忽略不计）

注：在嵌套的代码块中，不能定义同名变量。

构造代码块：类中方法外 `{}` 包含的代码。  
- 执行特征：创建对象的时候执行。  
  注：构造方法和构造代码块，都是在创建对象的时候执行，但是构造代码块先执行，构造方法后执行。

- 构造代码块的使用场景：
  1. 可以把多个构造方法方法中相同的代码提取放到构造代码块中；
  2. 可以用构造代码块来初始化对象的成员变量的值。  
  注：成员变量初始化语句和构造代码块的执行顺序按顺序结构。  

静态代码块：类中方法外，被 static 修饰。  
- 执行特征：随着类加载而执行，所以静态代码块还有一个特征 —— 至多执行一次。


**（5）package关键字**  

在 Java 源程序文件的第一行使用 package 声明，可以使文件中定义的类成为指定包的成员。  

声明语法：`package 包名;`。  

包名通常由多个名字字符串构成，中间用 `.` 分隔。每个名字表示的包称为其前面的名字表示的包的子包。  

通常以组织机构的域名反转形式作为其所有包的通用前缀，比如：`com.somecompany.apps`

注：Java 中定义的任何一个类，都是在某一个包下的。如果代码没声明所属的包，此时类会在 Java 中的一个默认包中。

**（6）import关键字**  

在类名前面加上类所属的包名，中间用 `.` 分隔，称为类的完全限定名（Full Qualified Name），简称类的限定名。  

当在类体中使用了与当前类不同包的类名时，编译器编译时会因为无法找到该类的定义而报错。对此有两个解决办法：  
1. 使用不同包类的完全限定名；
2. 使用 import 声明，为编译器提供该类的定义信息。

声明语法：`import <类的完全限定名>;`。  

注：
- import 声明一般紧跟在 package 声明之后，且必须在类声明之前。

- Java 语言核心包 java.lang 包中的类将被隐式导入，可以直接使用其中的类。

- import 声明提供了一种包的智能导入方式：`import <包名>.*;`。包中的类将根据需要导入，避免使用多条 import 声明。  
  注：智能导包（不会递归导入子包中的类）且按需导入。  


### 访问权限修饰符

在 Java 语言中，一切事物（类所有成员）都具有（或显示定义或隐式定义的）访问权限，而这种语言层面的访问权限控制，是由访问权限修饰符实现。  

访问权限修饰符的访问控制，分为 2 个层面：
- 修饰类中成员（field & method）  
  控制类中的成员，对其他类可见性（其他类是否可以直接使用到）。

- 修饰类  
  通常用来限定类库中的类（自定义数据类型），对于外部使用者的可见性（是否能使用该类型）。

修饰类中成员可以使用的访问权限修饰符有 4 种：
- public：任意类均访问，实际就是没有限制访问权限。  
  1. 类体中，可以直接访问；
  2. 同包的其他类中，也可以访问；
  3. 不同包的的类中，也可以访问。

- protected：同包中的其他类，和不同包的（可见）子类均可见。
  1. 类体中，可以直接访问；  
  2. 同包其他类中，可以访问；  
  3. 在非同包的一部分类中，访问不到（有一部分子类中可以访问到：父类中被 protected）。

- default：默认权限，隐式定义。
  1. 类体中，可以直接访问；
  2. 同包其他类中，可以访问；
  3. 不同包的类中，访问不了。

- private：仅对同类中的其他成员可见。  
  使用户不要触碰他们「不该」触碰的代码（private），类库设计者可以安全的修改实现细节。
  1. 类体中，可以访问
  2. 同包其他类中，无法访问
  3. 非同包中，无法访问  

针对 private 成员变量，专门定义 public 的方法，让外部能够访问私有成员变量的值。
- get：让外部读取到私有成员变量值
- set：让外部通过该方法，修改私有成员变量的值

同时，为了清楚的表名 get 和 set 分别获取和改变的是哪个成员变量的值，命名规则为：
`getXxx()`、`setXxx(修改目标值参数)`。

提供 get，set 方法的好处：
-  可以满足某些场景下，需要访问私有成员变量值的需求。

-  通过定义 get 和 set 方法来实现对私有成员变量的读写分离。

-  一旦一个成员变量被 private 修饰，别人就无法直接通过 `对象名.成员变量` 访问，只能通过 `set()` 此时我们在 set 方法中，就可以通过代码控制别人的修改。

各权限修饰符对成员的可见性的影响：  
| | public | protected | default | private |
| - | - | - | - | - | 
| 同一类 | √ | √ | √ | √ |
| 同包子类 / 其它类 | √ | √ | √ | |
| 不同包子类 | √ | √ |  |  |
| 不同包其它类 | √ |  |  |  |  


能够修饰类的访问权限修饰符只有 2 种：
- public：对其他任意类可见。  
  任何其他地方都可以访问到这个类（同一个 module 下），比如：同包中的其他类以及非同包的其他类。

- default：对同包中的其他类可以访问，非同包的类不可访问。


### 面向对象三大特征之封装

封装是一种信息隐藏技术，是指将数据和基于数据的操作封装在一起。  
数据被保护在内部，系统的其他部分只有通过在数据外面的被授权的操作才能够进行交互。  
目的在于将类使用者 class user 和类设计者 class creator 分开。  

在面向对象的编程中，用类来封装相关的数据和方法，保证了数据的安全和系统的严密性。

```
类
  成员变量（一定要考虑访问权限）

  构造方法
    无参构造方法
    带参构造方法

  成员方法
    getXxx()
    setXxx()
```
给成员变量赋值的方式：
-  无参构造方法 + setXxx()；
-  带参构造方法。

### 面向对象三大特征之继承

Java 中的继承和我们现实生活中的「继承」的含义基本类似，但是含义更广。
- 简单来说都可以表示「不劳而获」（类似于现实世界中继承的含义）。

- 类型之间「is a」的关系：一种类型（类）继承另外一种类型（类）。

被继承的类称之为父类（基类或超类），继承其他类的类称之为子类（派生类，导出类）。

子类可以通过继承机制，不写任何额外代码就可以拥有父类的「所有」成员。

继承的语法：`class 子类名 extends 父类名 {}`。  

继承的优点：
- 代码复用（方法，类）。

- 提高了代码的可维护性（这是一把双刃剑）。

- 弱化 Java 中的类型约束（多态的前提）。

继承的缺点：父类的修改可能会出现在所有子类中（我们无法选择这些修改可以反应在哪些子类中，不可以反应在哪些子类中）。

Java 继承的特点：在 Java 中只能实现单重继承。  
单重继承：简单来说 Java 的 extends 关键字后只能跟一个。当然这并不意味着一个 Java 类只能继承某一个类的成员（可以间接继承）。
```java
class SubDemo extends Demo{} //ok
class SubDemo extends Demo1,Demo2{} //error
```

继承的注意事项：  
- 子类只能访问父类所有非私有的成员（成员方法和成员变量）。

- 子类不能继承父类的构造方法。


结合面向对象相关知识，子类继承父类，于是子类拥有了父类的成员，同时，子类本身又可以定义属于自己的成员，这样一来一个子类对象中包含的数据，其实由两部分组成：  
- 父类包含的可继承的成员（成员变量和成员方法）。

- 子类中自己定义的成员。

一旦子类继承了父类，那么在创建子类对象、初始化子类对象的过程、子类对象的初始化过程和之前相比也会有较大的不同。  
根本原因在于子类对象初始化时要初始化父类对象和子类对象两部分数据，而且父类对象（即父类成员部分）都应该先于子类对象（即子类中自己定义的成员部分）而被初始化。  
这种优先关系可以从 2 个角度去理解：  
- 直觉：儿子能继承父亲的前提是，父亲先存在。

- JVM：子类成员变量的初始化可能依赖于父类成员。

在 Java 语言中，子类对象的初始化有两种，隐式初始化和显式初始化。
- 隐式初始化  
  当父类提供了默认的构造方法且子类的构造方法中没有显式调用父类的其它构造方法时，在执行子类的构造方法之前会自动执行父类的构造方法。  

- 显式初始化  
  通过 super 关键字。
  

super 关键字：this 代表当前这个对象，代表对象的内存空间标识（当前类定义的内容）。super 代表对象的内存空间的标识（父类定义的内容）。

用法：  
- 访问成员变量：`super.成员变量`

- 访问构造方法：`super(实参列表)`

- 访问成员方法：`super.成员方法()`

父类域的隐藏：如果在子类中定义了和父类同名的成员变量，则在子类类体中，通过同名变量名访问到的是子类中定义的成员变量。看起来就好像父类成员变量在子类中被隐藏。

注：
- 在父类方法的方法体中，通过同名成员变量的名访问到的是父类中定义的成员变量。

- 通过 super 关键字也可以在子类对象中访问到父类中的同名成员变量。

方法覆盖的问题：当子类中定义了和父类「一模一样」的方法，在子类方法体中，访问到的是子类中定义的方法。如果我们在父类方法的方法体中，访问那个「一模一样」的方法，访问到的仍然是子类中的方法。即当子类父类定义「一模一样」的方法时，子类方法覆盖父类方法。  

方法覆盖发生的条件「一模一样」主要看的是子类和父类的方法声明部分：访问权限、返回值、法签名。
- 方法声明的访问权限的条件  
  并非子类和父类方法的访问权限要相同，只要子类方法的访问权限不小于父类方法的访问权限。

- 方法返回值
  - 基本数据类型的方法返回值：子类必须和父类相同。

  - 引用数据类型  
    子类父类返回值类型相同；  
    或子类方法返回值类型是父类方法返回值类型的子类类型（因为可以把子类类型看做是父类类型）。

- 方法签名  
  子类方法的方法签名必须和父类一样。

方法覆盖的使用场景：当子类继承父类之后，想要修改父类的方法，就可以使用方法覆盖。

注：  
- 父类中私有方法不能被重写。

- 静态方法不能被重写！！

final 关键字：final 是最终的意思，可以修饰类，变量，成员方法。  
- 修饰类，类不能被继承。

- 修饰变量，变量就变成了常量，且只能被赋值一次。  
  - 修饰成员变量：必须在定义时初始化。  
    对于成员变量而言，如果被 final 修饰，必须在对象创建完毕之前，给对象的该成员变量值赋值。

  - 修饰局部变量：可以在定义时初始化，也可以选择在构造方法中进行初始化。  
    对于局部变量而言，如果被 final 修饰，那么该变量必须在使用之前赋值。

- 修饰方法，方法不能被重写（override）。


### 面向对象三大特征之多态  

多态：某一个事物在不同时刻（或条件下）表现出来的不同状态。  
Java 语言中的多态：同一个对象的行为在不同的时刻或条件下表现出不同的效果。

要实现多态的效果有前提条件：
1. 继承；
2. 要有方法覆盖；
3. 父类引用指向子类对象（对象有时也称之为实例）。

父类引用指向子类对象，去访问子类对象中的成员时（多态的特征）：
- 成员变量：编译看左边，运行看左边。  
  通过引用变量访问到的子类成员的范围，是由引用类型来决定的。

- 成员方法：编译看左边，运行看右边。  
  通过引用变量访问到的方法，是由引用实际指向的对象来决定的。

多态的好处：
- 提高了程序的维护性（由继承保证）。

- 提高了程序的扩展性（由多态保证）。

多态的弊端：
- 不能访问子类特有功能。  
  通过多态的转型可以解决。

多态中的转型：  
- 向上转型：从子到父，即父类引用指向子类对象。  
  注意：向上转型，是 Java 语言天生就允许的。

- 向下转型：从父到子，即父类引用转为子类对象的引用。  
  注意：向下转型是不安全的，因此 Java 语言默认不允许向下转型。但是通过 instanceof 关键字可以做到安全的向下转型。
  
instanceof 关键字：instanceof 关键字的作用是判断其左边对象是否为其右边类的实例，返回 boolean 类型的数据。可以用来判断继承中的子类的实例是否为父类的实现。  

语法：`对象名 instanceof 类名`。