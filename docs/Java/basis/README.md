# 一、Java 入门

## 目录

- [一、Java 入门](#一java-入门)
  - [目录](#目录)
  - [3 Java 语言基础](#3-java-语言基础)
    - [3.1 关键字](#31-关键字)
    - [3.2 标识符](#32-标识符)
  - [4 Java 流程控制](#4-java-流程控制)
  - [5 方法](#5-方法)
    - [5.1 方法定义](#51-方法定义)
    - [5.2 方法重载](#52-方法重载)
    - [5.3 递归](#53-递归)
  - [6 数组](#6-数组)
    - [6.1 概念](#61-概念)
    - [6.2 数组的初始化](#62-数组的初始化)
    - [6.3 数组拷贝](#63-数组拷贝)
    - [6.4 二维数组](#64-二维数组)
    - [6.5 数组常见报错](#65-数组常见报错)
  - [7 Java 中的内存](#7-java-中的内存)



## 3 Java 语言基础

### 3.1 关键字  



### 3.2 标识符







## 4 Java 流程控制



## 5 方法

### 5.1 方法定义

方法（在有些其他语言中，也被称为函数）的主要功能是封装可以执行的一段代码，这样不仅可以进行重复调用，更可以方便地实现代码的维护。  

方法定义的格式：  
```java
修饰符 返回值类型 方法名 (参数1 类型 参数1 名称, 参数2 类型 参数2 名称, ……) {
    方法体语句
    return 返回值;
}
```

格式说明：  
- 修饰符：现在暂且认为固定 `public static`。  

- 返回值类型：return 返回的数据类型。

- 方法名：标识符。

- 参数：类比数学中函数的自变量，如 z = f(x, y) 里的 x，y。

- return：跳转控制关键字。

- 返回值：方法执行的到的最终结果。

注：返回值类型为 void 时，可以不使用 return 返回内容，但是可以使用 return 结束方法调用。

方法在定义完毕后，方法不会自己运行，必须被调用才能执行，我们可以在主方法 main 中来调用我们自己定义好的方法。在主方法中，直接写要调用的方法名字就可以调用了。  
示例：
```java
public static void main(String[] args) {
    // 调用定义的方法 method
    method();
}

// 定义方法，被 main 方法调用
public static void method() {
    System.out.println("自己定义的方法，需要被 main 调用运行");
}
```

### 5.2 方法重载

方法重载（overload）：在同一个类中，允许存在一个以上的同名方法，只要它们的「参数个数 / 参数类型 / 参数顺序」不同。  
示例：  
```java
public static int add(int x, int y) {
  return x + y;
}

// 方法重载
public static double add(double x, double y) {  
  return x + y;
}
```

注：方法重载的时候是根据参数类型及个数来区分不同的方法，而不是依靠返回值的不同来确定。  

### 5.3 递归

递归调用是一种特殊的调用形式，指的是方法自己调用自己的形式。递归调用必须满足两个条件：  
1. 必须有结束条件；

2. 每次调用必须改变传递的参数。

示例：
```java
// 求阶乘
public static fac(int n) {
  if (n == 1) {
    return 1;
  }
  return n * fac(n - 1);
}
```

注：开发中应当避免过多的使用递归，因为处理不当，就可能造成栈溢出问题。

## 6 数组 

### 6.1 概念

数组的概念：相同数据类型的数据元素的有序（物理地址有序非元素有序）集合。通过一个整型下标就可以访问数组中的每一个元素。  

特点：  
- 存储多个数据元素。

- 这多个数据元素的数据类型必须一致。

可以存储的数据类型：  
- 基本类型数据。  

- 引用类型数据。

数组的定义格式：  
- 格式1：
  ```java
  数据类型[] 数组名;
  ```

- 格式2：
  ```java
  数据类型 数组名[];
  ```

建议使用格式1，避免造成歧义。

### 6.2 数组的初始化

数组的初始化：为数组中的数组元素分配内存空间，并为每个数组元素赋初值。Java 中的数组必须先初始化，然后才能使用。  

数组的初始化方式：  
- 动态初始化（指定长度）。格式：
  ```java
  数据类型[] 数组名 = new 数据类型[数组长度];
  ```  
  示例：  
  ```java
  int[] arr = new int[3];
  ```  

- 静态初始化（指定内容）。格式：
  ```java
  数据类型[] 数组名 = new 数据类型[]{元素1, 元素2, …};
  ```  
  示例：  
  ```java
  int[] arr1 = new int[]{1, 2, 3};

  int[] arr2 = {1, 2, 3}; // 简化写法
  ```
  注：简化写法只在数组定义时有效！

注：
- 一旦创建了数组就不能再改变它的大小。如果经常需要在运行中拓展数组的大小，就应该使用另外一种数据结构 —— 数组列表（Arraylist），之后会详细介绍。  

- 字符串类型的数据不是基本数据类型的数据，我们所说的一个字符串，其实是一个字符串对象。字符串对象存储在数组中，数组中其实存储的是对象的地址值，并未直接存储字符串中的字符序列数据，而同一个 JVM 中的引用值（地址值）占用的内存大小相同。


### 6.3 数组拷贝

在 Java 中，允许将一个数组拷贝给另一个数组变量。这时两个变量将引用同一个数组。  
示例：
```java
int[] arr2 = arr1;
arr2[3] = 5; // 这时 arr1[3] 也等于 5
```

如果希望将一个数组的所有值拷贝到一个新的数组中去，可以使用 Arrays 类中的 copyOf 方法。  
示例：    
```java
int[] arr2 = Arrays.copyOf(arr1, arr1.length);
```
参数2 确定新数组的长度，因此这个方法常用来调整数组的长度。如果参数2 小于原始长度，则只拷贝最前面的数据元素。

### 6.4 二维数组

相对于一维数组单行多列的结构，二维数组就是一张多行多列的数据表结构。  

定义格式：  
- 动态初始化：
  ```java
  数据类型[][] 数组名 = new 数据类型[行的长度][列的长度];
  ```  
  示例：  
  ```java
  int[][] arr = new int[10][10]
  ```

- 静态初始化：
  ```java
  数据类型[][] 数组名 = {
      {}, 
      {}, 
      {}
  };
  ```  
  示例：  
  ```java
  int[][] arr = {
      {1, 2, 3},
      {3, 4, 6},
      {7, 8, 9}
  };
  ```

注：for each 循环语句不能自动处理二维数组的每一个元素。它是按行，也就是一位数组处理的。想要访问二维数组的所有元素，需要使用两个嵌套的循环。  
示例：
```java
for (int[] row : arr) {
    for (int value : row) {
        循环语句
    }
}
```
 
- Java 实际上没有多维数组，只有一维数组。多维数组实际上是「数组的数组」。因此 Java 中可以构建不规则数组，即数组的每一行有不同的长度。   

Java 中允许定义不规则的多维数组。  
不规则数组动态定义格式：`数据类型[][] 数组名 = new 数据类型[行的长度][];`。  
示例：
```java
int[][] arr = new int[3][];
for (int i = 0; i < arr.length; i++) {
  int[i] = new int[i + 1];
}
/*
构建了不规则数组：
{
  {长度为 1},
  {长度为 2},
  {长度为 3}
}
*/
```


### 6.5 数组常见报错

`ArrayIndexOutOfBoundsException`：数组索引越界。  

`NullPointerException`：空指针异常。 

## 7 Java 中的内存

一个 Java 程序在 JVM 中运行的过程中，在内存中需要保存很多种内存数据，比如局部变量、数组等。不同类型的数据，其使用方式和生命周期都不相同。为了更好的管理这些不同类型的数据，JVM 把自己的内存空间划分为不同的内存区域。各个区域针对不同类型的数据采用不同的管理方式：  
- 栈（Stack）：存放的都是方法中的局部变量。方法的运行一定要在栈当中运行。  
  一旦超出作用域，立刻从栈内存当中消失。

- 堆（Heap）：存储关键字 new 开辟出来的东西，即保存每一个对象的属性内容。  
  堆内存里面的东西都有一个 16 进制的地址值。  
  堆内存里的数据天然有初值：
  - 整型：0。
  - 浮点型：0.0。
  - 字符型：'\u000'。
  - 布尔型：false。
  - 引入数据类型：null。  

- 方法区（Method Area）：存储 .class 相关信息，包含方法的信息。

- 本地方法栈（Native Method Stack）：与操作系统相关。

- 寄存器（pc Register）：与 CPU 相关。

个人理解：  
当定义一个变量，如 `int a = 1` 时，栈是先开辟地址，这个地址存放值 1，然后让变量名 a 指向这个地址。如果又定义了新的变量等于这个值，如 `int b = 1`，那直接让新的变量名 b 也指向这个地址。如果修改新的变量值，如 `b = 2`，并不会修改这块地址的值（即 a 依旧为 1），而是重新指向一块值为 2 的地址（如果没有，就再开辟一块地址，令值为 2）。如果变量都离开了作用域，即没有变量指向这块地址，就把这块地址回收。  
堆是申请一片地址，数组名指向这个地址。修改数组，就直接修改这块地址的数据。
