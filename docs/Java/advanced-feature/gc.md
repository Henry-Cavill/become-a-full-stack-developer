## Memoery

Java 虚拟机在 Java 程序运行过程中会把它管理的内存划分为若干个不同的数据区域。这些区域有各自的用途以及创建和销毁的时间，有的区域随虚拟机的启动而存在，有些区域依赖用户线程的启动和结束而建立和销毁。

根据 《Java虚拟机规范》，Java 虚拟机所管理的内存将会包括如下图的几个运行时数据区：

![](./img/p7.png)

程序计数器：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。

Java 虚拟机栈：它描述的是 Java 方法执行的内存模型。每个方法被执行的时候都会同时创建一个栈帧（Stack Frame ）用于存储局部变量表、操作栈、动态链接、方法出口等信息。

本地方法栈：本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的 Native 方法服务。

Java 堆：此内存区域的唯一目的就是存放对象实例。一个 JVM 实例只存在一个堆，堆内存的大小是可以调节的，堆内存是线程共享的。

方法区：方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量等数据。

## GC 相关概念

内存管理管理的方式通常有两种：
- 显式的内存管理（C/C++）：内存管理（内存的申请和释放）是程序开发者的职责。
  
  常见问题：  
  - 内存泄漏：内存空间已经申请，使用完毕后未主动释放。  

  - 野指针：使用了一个指针，但是该指针指向的内存空间已经被 free。

- 隐式的内存管理（Java/C#）：内存的管理是由垃圾回收器自动管理的。

  优点：增加了程序的可靠性，减小了 memory leak。  
  缺点：无法控制 GC（Garbage Collection）的时间，耗费系统性能，无法消除内存泄漏。

相关概念：
- Shallow size 就是对象本身占用的内存大小，也就是对象头加成员变量占用内存大小的总和。

- Retained size 是该对象自己的 shallow size 加上仅可以从该对象访问（直接或者间接访问）的对象的 shallow size 之和。

- Retained size 是该对象被 GC 之后所能回收的内存的总和。

研究 GC，就必须要面对 3 个问题：
1. 如何确定垃圾；

2. 如何回收垃圾；

3. 何时触发 GC。

## 如何确定垃圾

最简单的算法就是引用计数法：
1. 给对象添加一个引用计数器；

2. 每当一个地方引用它时，计数器加 1；

3. 每当引用失效时，计数器减少 1；

4. 当计数器的数值为 0 时，也就是对象无法被引用时，表明对象不可在使用。

但是这个算法存在一个致命的缺陷，无法解决循环引用的问题。为此，引入了另外一种根搜索算法。

根搜索算的基本思想：
1. 将一系列称为「GC Roots」的对象作为起始点；

2. 从这些节点开始向下搜索；

3. 搜索所走的路径称为引用链；

4. 当一个对象到所有的 GC root 之间没有任何引用链相连时，就认为该对象变成了垃圾。

GC Roots 包含：
- 虚拟机栈中引用的对象。

- 方法区中的静态属性引用的对象。

## 如何回收垃圾 

GC 中如何回收垃圾呢：
- 标记清除算法（Mark Sweep）：  
  ![](img/p8.png)

- 标记复制算法（Copy）：  
  ![](img/p9.png)

- 标记整理算法（Mark Compact）：  
  ![](img/p10.png)

- 分代收集算法（Generational Collection 商用）：这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最合适的收集算法。
  - 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

  - 而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记整理算法进行回收。

## 何时触发 GC

GC 触发的时机：
- 申请 heap space 失败后会触发 GC 回收。

- 系统进入 idle 后一段时间会进行回收。

- 主动调用 GC 进行回收。